name: CI & Docker Release

on:
  pull_request:
    branches:
    - 'prod'
    types:
    - closed

jobs:
  run-tests:
    if: github.event.pull_request.merged == true
    permissions:
      contents: write
    strategy:
      fail-fast: true
    uses: ./.github/workflows/tests.yml

  # ==========================
  #  Handle Prod Release Tags
  # ==========================
  release-flow:
    name: Handle Releases Tags
    runs-on: ubuntu-latest
    needs: run-tests
    permissions:
      contents: write
    strategy:
      fail-fast: true
    outputs:
      tag: ${{ steps.version.outputs.TAG }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        ref: prod

    - name: Ensure VERSION file exists
      run: |
        VERSION_FILE="VERSION"
        if [ ! -f "$VERSION_FILE" ]; then
            echo "0.1.0" > "$VERSION_FILE"
        fi

    - name: Fetch full git history and tags
      run: |
        git fetch --unshallow --tags || git fetch --tags

    - name: Bump version
      id: version
      run: |
        VERSION_FILE="VERSION"
        CURRENT_VERSION=$(cat $VERSION_FILE)
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        # Prod never updates any versions on its own
        TAG="$MAJOR.$MINOR.$PATCH"

        echo "::notice::Release Tag: $TAG"
        echo "TAG=$TAG" >> $GITHUB_OUTPUT

    - name: Create and push Git tag
      if: steps.version.outputs.TAG != ''
      env:
        TAG: ${{ steps.version.outputs.TAG }}
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag already exists."
            exit 0
        fi

        git tag ${{ steps.version.outputs.TAG }}
        git push origin ${{ steps.version.outputs.TAG }}

  # ==========================
  #  Publish Docker Image
  # ==========================
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [ release-flow ]
    permissions:
      contents: write

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        ref: prod
        fetch-depth: 0
        submodules: false # Optional â€” only needed if using submodules
        persist-credentials: false # not needed unless you push

    - name: Update .env.docker
      run: |
        sed -i "s/DOCKER_RELEASE=.*/DOCKER_RELEASE=latest/" docker/.env.docker

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}

    - name: Push to Docker Hub
      uses: docker/build-push-action@v6
      with:
        context: .
        push: true
        tags: |
          aminnausin/mediaserver:latest
          aminnausin/mediaserver:${{ needs.release-flow.outputs.tag }}

  # ==========================
  #  Check for Docker Changes
  # ==========================
  check-docker-changes:
    name: Check for Docker Related File Changes
    needs: [ run-tests ]
    if: needs.run-tests.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      files_changed: ${{ steps.filter.outputs.changes != '[]' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: prod

    - name: Check for file changes
      id: filter
      uses: dorny/paths-filter@v2
      with:
        filters: |
          changed:
              - 'docker/**'
              - 'docker-compose.yaml'
              - 'Dockerfile'
              - 'startDocker.*'
              - 'data/**'
              - 'README.md'

  # ==========================
  #  Release Docker Setup Pkg (Always)
  # ==========================
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [ build-docker, check-docker-changes, release-flow ]
    permissions:
      contents: write

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        ref: prod

    - name: Prepare default data files for release
      run: |
        mkdir -p data
        cp -r storage/app/public/* data

    - name: Zip Files Linux
      run: |
        zip -r mediaServerDockerLinux.zip ./docker/etc ./docker/.env.docker ./docker-compose.yaml ./startDocker.sh ./README.md ./data/*

    - name: Zip Files Windows
      run: |
        zip -r mediaServerDockerWindows.zip ./docker/etc ./docker/.env.docker ./docker-compose.yaml ./startDocker.bat ./README.md ./data/* ./add-hosts-entry.ps1

    - name: Cleanup temp
      run: rm -rf temp

    - name: Create Release
      uses: ncipollo/release-action@v1
      with:
        allowUpdates: false
        token: ${{ secrets.GITHUB_TOKEN }}
        tag: ${{ needs.release-flow.outputs.tag }}
        name: Release - ${{ needs.release-flow.outputs.tag }}
        draft: false
        prerelease: false
        artifacts: mediaServerDockerLinux.zip,mediaServerDockerWindows.zip

  # ==========================
  #  Bump Main to Next Version (Only on Prod)
  # ==========================
  bump-main-version:
    name: Bump Main to Next Beta Base Version
    needs: release-flow
    if: needs.release-flow.outputs.tag != '' && github.event.pull_request.head.ref == 'main' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        ref: main

    - name: Bump main version
      run: |
        VERSION_FILE="VERSION"
        CURRENT_VERSION=$(cat $VERSION_FILE)

        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        # Always bump MINOR after prod
        MINOR=$((MINOR + 1))
        PATCH=0

        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        TAG="${NEW_VERSION}-beta.0"

        echo "$NEW_VERSION" > $VERSION_FILE

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        git add VERSION
        git commit -m "chore: bump main to $TAG"
        git push origin main

        git tag $TAG
        git push origin $TAG
